<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Click Timing Challenge</title>
  <style>
    :root{
      --bg:#0b0f17; --fg:#e7ecf3; --muted:#9fb0c3;
      --accent:#3ff0c1; --accent2:#77a6ff; --danger:#ff5c7a; --ring:#1c2940;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color:var(--fg); background:radial-gradient(1200px 800px at 70% 20%, #101a2a 0, #0b0f17 50%, #070a10 100%);
      display:flex; align-items:center; justify-content:center; overflow:hidden;
    }
    .card{
      width:min(92vw, 820px);
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.08);
      border-radius:24px; padding:22px 22px 18px; box-shadow:0 20px 60px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:10px;
    }
    h1{font-size:22px; margin:0; letter-spacing:.2px}
    .muted{color:var(--muted); font-size:14px}
    .row{display:flex; gap:14px; flex-wrap:wrap; align-items:center}
    .pill{
      border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:8px 12px; font-size:13px; color:var(--muted);
      display:inline-flex; gap:8px; align-items:center; background:rgba(255,255,255,0.03)
    }
    .accent{color:var(--accent)}
    .danger{color:var(--danger)}
    .wrap{display:grid; grid-template-columns:1fr 320px; gap:18px}
    @media (max-width:900px){ .wrap{grid-template-columns:1fr} }
    canvas{width:100%; height:auto; display:block; aspect-ratio:1/1; border-radius:20px; background:linear-gradient(180deg, #0d1322, #0a1120)}
    .side{
      display:flex; flex-direction:column; gap:12px; align-self:stretch; justify-content:space-between;
    }
    button{
      appearance:none; border:none; border-radius:14px; padding:12px 14px; font-weight:600; cursor:pointer;
      color:#08111a; background:linear-gradient(180deg, var(--accent), #11d39d);
      box-shadow:0 10px 30px rgba(63,240,193,.35);
    }
    button.secondary{
      background:transparent; color:var(--fg); border:1px solid rgba(255,255,255,.14);
      box-shadow:none;
    }
    .stats{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .stat{
      background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:10px 12px; min-height:64px;
    }
    .stat .label{font-size:12px; color:var(--muted)}
    .stat .value{font-size:20px; font-weight:700; margin-top:6px}
    .result{
      margin-top:6px; font-size:14px; color:var(--muted)
    }
    .note{font-size:12px; color:var(--muted)}
    .toggle{display:flex; align-items:center; gap:10px; font-size:13px; color:var(--muted)}
    .toggle input{transform:scale(1.1)}
    footer{margin-top:10px; display:flex; justify-content:space-between; align-items:center; gap:10px}
    kbd{background:#0f1726; border:1px solid rgba(255,255,255,.1); border-bottom-color:rgba(0,0,0,.4);
        padding:2px 6px; border-radius:6px; font-size:12px; color:var(--muted)}
  </style>
</head>
<body>
  <div class="card" role="application" aria-label="Timing game">
    <header>
      <h1>Click Timing Challenge</h1>
      <div class="row">
        <span class="pill"><span>Goal:</span><strong class="accent">Stop on the glowing arc</strong></span>
        <span class="pill"><span>Controls:</span><kbd>SPACE</kbd> or <kbd>Click / Tap</kbd></span>
      </div>
    </header>

    <div class="wrap">
      <!-- GAME CANVAS -->
      <canvas id="game" width="640" height="640" aria-label="game board"></canvas>

      <!-- SIDE PANEL -->
      <div class="side">
        <div>
          <div class="stats">
            <div class="stat">
              <div class="label">Last time</div>
              <div class="value" id="timeVal">—</div>
              <div class="result" id="hitVal">—</div>
            </div>
            <div class="stat">
              <div class="label">Best (within target)</div>
              <div class="value" id="bestVal">—</div>
              <div class="result" id="bestInfo">—</div>
            </div>
          </div>

          <div class="stats">
            <div class="stat">
              <div class="label">Angle error</div>
              <div class="value" id="errVal">—</div>
              <div class="result">Lower is better (° from center)</div>
            </div>
            <div class="stat">
              <div class="label">High Score</div>
              <div class="value" id="scoreVal">—</div>
              <div class="result">Combines speed + accuracy</div>
            </div>
          </div>
        </div>

        <div>
          <div class="row" style="margin:8px 0 10px">
            <button id="startBtn" aria-label="Start game">Start</button>
            <button id="againBtn" class="secondary" aria-label="Play again" disabled>Again</button>
          </div>
          <label class="toggle">
            <input type="checkbox" id="postScoreChk" />
            Send score to <code>/score</code> on this server (username “jake”)
          </label>
          <p class="note">
            How it works: a neon arc appears on the ring. A glowing dot spins around — stop it
            <em>inside the arc</em>. We measure using <code>performance.now()</code> for sub-ms precision.
          </p>
        </div>

        <footer class="muted">
          <span>Pro tip: press <kbd>SPACE</kbd> to stop.</span>
          <span id="stateText">Idle</span>
        </footer>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI elements
      const timeVal = document.getElementById('timeVal');
      const errVal = document.getElementById('errVal');
      const scoreVal = document.getElementById('scoreVal');
      const bestVal = document.getElementById('bestVal');
      const bestInfo = document.getElementById('bestInfo');
      const startBtn = document.getElementById('startBtn');
      const againBtn = document.getElementById('againBtn');
      const stateText = document.getElementById('stateText');
      const postScoreChk = document.getElementById('postScoreChk');

      // Game state
      const STATE = { IDLE:'idle', COUNTDOWN:'countdown', RUN:'run', RESULT:'result' };
      let state = STATE.IDLE;

      // Ring geometry
      const R = 240;         // ring radius
      const DOT_R = 10;      // dot radius
      const cx = canvas.width/2, cy = canvas.height/2;

      // Target & motion
      let targetCenter = 0;  // radians
      let targetWidth = deg2rad(32); // radians (arc size)
      let spinRPS = 1.6;     // rotations per second (randomized per round)
      let startAngle = 0;    // start angle
      let angle = 0;
      let tStart = 0;        // perf.now at start
      let raf = 0;

      // Results
      let lastTimeMs = null;
      let lastErrDeg = null;
      let lastScore = null;

      // Bests (persist)
      const best = JSON.parse(localStorage.getItem('ctc_best') || '{"timeMs":null,"errDeg":null,"score":null}');
      updateBestUI();

      // Helpers
      function deg2rad(d){ return d * Math.PI / 180; }
      function rad2deg(r){ return r * 180 / Math.PI; }
      function wrapPI(x){ // wrap to [-PI, PI]
        while (x > Math.PI) x -= 2*Math.PI;
        while (x < -Math.PI) x += 2*Math.PI;
        return x;
      }

      function setState(s){ state = s; stateText.textContent = s.toUpperCase(); }
      function formatMs(ms){ return `${ms.toFixed(3)} ms`; }

      function drawScene(now){
        // background
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // outer glow ring
        ctx.save();
        const grad = ctx.createRadialGradient(cx,cy,R-40,cx,cy,R+60);
        grad.addColorStop(0, 'rgba(63,240,193,0.06)');
        grad.addColorStop(1, 'rgba(119,166,255,0.05)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx,cy,R+60,0,Math.PI*2);
        ctx.arc(cx,cy,R-60,Math.PI*2,0,true);
        ctx.fill();
        ctx.restore();

        // base ring
        ctx.lineWidth = 16;
        ctx.strokeStyle = '#1c2940';
        ctx.beginPath();
        ctx.arc(cx,cy,R,0,Math.PI*2);
        ctx.stroke();

        // target arc (neon)
        const pulse = 0.4 + 0.6 * (0.5 + 0.5*Math.sin((now/400)));
        ctx.lineCap = 'round';
        ctx.lineWidth = 22;
        const g2 = ctx.createLinearGradient(0, cy-R, canvas.width, cy+R);
        g2.addColorStop(0, 'rgba(63,240,193,0.95)');
        g2.addColorStop(1, 'rgba(119,166,255,0.95)');
        ctx.strokeStyle = g2;
        ctx.globalAlpha = state === STATE.RUN ? 1 : 0.8 + 0.2*Math.sin(now/300);
        ctx.beginPath();
        ctx.arc(cx,cy,R, targetCenter - targetWidth/2, targetCenter + targetWidth/2);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // rotating dot + tail when running
        if (state === STATE.RUN || state === STATE.RESULT){
          // trail
          const trailLen = deg2rad(35);
          ctx.save();
          ctx.lineWidth = 10;
          const tailGrad = ctx.createLinearGradient(0,0,canvas.width,0);
          tailGrad.addColorStop(0,'rgba(119,166,255,0.0)');
          tailGrad.addColorStop(1,'rgba(63,240,193,0.6)');
          ctx.strokeStyle = tailGrad;
          ctx.beginPath();
          ctx.arc(cx,cy,R, angle - trailLen, angle);
          ctx.stroke();
          ctx.restore();

          // dot glow
          const dx = cx + R*Math.cos(angle);
          const dy = cy + R*Math.sin(angle);
          const glow = ctx.createRadialGradient(dx,dy,2,dx,dy,30);
          glow.addColorStop(0,'rgba(63,240,193,0.9)');
          glow.addColorStop(1,'rgba(63,240,193,0)');
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(dx,dy,30,0,Math.PI*2);
          ctx.fill();

          // dot
          ctx.fillStyle = '#3ff0c1';
          ctx.beginPath();
          ctx.arc(dx,dy,DOT_R,0,Math.PI*2);
          ctx.fill();
        }

        // center text/status
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.font = '600 28px ui-sans-serif, system-ui, -apple-system, Segoe UI';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (state === STATE.IDLE){
          ctx.fillText('Press START', cx, cy - 14);
          ctx.fillStyle = 'rgba(159,176,195,0.9)';
          ctx.font = '400 16px ui-sans-serif, system-ui';
          ctx.fillText('Stop the dot on the glowing arc', cx, cy + 14);
        } else if (state === STATE.COUNTDOWN){
          const t = (performance.now() - tStart)/1000;
          const left = Math.max(0, 3 - Math.floor(t+1));
          ctx.fillText(left > 0 ? left.toString() : 'GO!', cx, cy);
        } else if (state === STATE.RESULT){
          ctx.fillText(lastScore != null ? `Score: ${lastScore}` : 'Result', cx, cy - 16);
          ctx.fillStyle = lastErrDeg!=null && lastErrDeg <= rad2deg(targetWidth)/2 ? '#3ff0c1' : '#ff5c7a';
          ctx.font = '700 22px ui-sans-serif, system-ui';
          const verdict = (lastErrDeg!=null && lastErrDeg <= rad2deg(targetWidth)/2) ? 'HIT!' : 'MISS';
          ctx.fillText(`${verdict}  •  Δ${lastErrDeg?.toFixed(2)}°`, cx, cy + 18);
        }
      }

      function loop(){
        const now = performance.now();
        if (state === STATE.RUN){
          const t = (now - tStart) / 1000; // seconds
          angle = startAngle + t * spinRPS * Math.PI * 2;
        }
        drawScene(now);
        raf = requestAnimationFrame(loop);
      }

      function startRound(){
        // randomize target & speed
        targetCenter = Math.random() * Math.PI * 2;
        targetWidth = deg2rad(28 + Math.random()*12); // 28°–40°
        spinRPS = 1.2 + Math.random()*1.4;           // 1.2–2.6 rps
        startAngle = Math.random()*Math.PI*2;

        angle = startAngle;
        lastTimeMs = null; lastErrDeg = null; lastScore = null;
        updateLastUI();

        setState(STATE.COUNTDOWN);
        tStart = performance.now();
        againBtn.disabled = true;
        startBtn.disabled = true;

        // short 3..2..1..GO countdown before run starts
        setTimeout(() => {
          setState(STATE.RUN);
          tStart = performance.now();
        }, 2200);
      }

      function stopRound(){
        if (state !== STATE.RUN) return;
        const tEnd = performance.now();
        lastTimeMs = tEnd - tStart;

        const d = wrapPI(angle - targetCenter);
        const errAbs = Math.abs(d); // radians
        lastErrDeg = rad2deg(errAbs);

        const hit = errAbs <= (targetWidth/2);
        // Score: higher is better; perfect center and super fast -> big score
        // (max around 1000+, but mostly 200-1000)
        const timeFactor = Math.max(0, 800 - lastTimeMs); // faster -> bigger
        const accFactor = Math.max(0, 500 - (lastErrDeg*10)); // precise -> bigger
        lastScore = Math.max(0, Math.round(200 + timeFactor + accFactor));

        // Update bests only on hit
        if (hit){
          if (best.timeMs === null || lastTimeMs < best.timeMs) best.timeMs = lastTimeMs;
          if (best.errDeg === null || lastErrDeg < best.errDeg) best.errDeg = lastErrDeg;
          if (best.score === null || lastScore > best.score) best.score = lastScore;
          localStorage.setItem('ctc_best', JSON.stringify(best));
          updateBestUI();
        }

        updateLastUI();
        setState(STATE.RESULT);
        againBtn.disabled = false;

        if (postScoreChk.checked){
          // Optional: send to your .NET endpoint; ignore failures
          fetch('/score', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ username:'jake', value: lastScore })
          }).catch(()=>{});
        }
      }

      function updateLastUI(){
        timeVal.textContent = (lastTimeMs==null) ? '—' : formatMs(lastTimeMs);
        errVal.textContent = (lastErrDeg==null) ? '—' : `${lastErrDeg.toFixed(2)}°`;
        scoreVal.textContent = (lastScore==null) ? '—' : `${lastScore}`;
        const hit = lastErrDeg!=null && lastErrDeg <= rad2deg(targetWidth)/2;
        const hitTxt = (lastErrDeg==null) ? '—' : (hit ? '✅ Inside target' : '❌ Outside target');
        document.getElementById('hitVal').textContent = hitTxt;
      }

      function updateBestUI(){
        bestVal.textContent = (best.timeMs==null) ? '—' : formatMs(best.timeMs);
        bestInfo.textContent = (best.errDeg==null && best.score==null)
          ? '—'
          : `Δ${best.errDeg?.toFixed(2) ?? '—'}°, score ${best.score ?? '—'}`;
      }

      // Input handlers
      function handlePress(){
        if (state === STATE.IDLE || state === STATE.RESULT){
          startRound();
        } else if (state === STATE.COUNTDOWN){
          // ignore
        } else if (state === STATE.RUN){
          stopRound();
        }
      }

      startBtn.addEventListener('click', handlePress);
      againBtn.addEventListener('click', handlePress);
      canvas.addEventListener('click', handlePress, {passive:true});
      canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); handlePress(); }, {passive:false});
      window.addEventListener('keydown', (e)=>{
        if (e.code === 'Space'){ e.preventDefault(); handlePress(); }
      });

      // Kick off render loop
      setState(STATE.IDLE);
      loop();

      // Resize handling to keep crisp canvas if you tweak CSS
      const ro = new ResizeObserver(()=>{
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.width * dpr);
      });
      ro.observe(canvas);
    })();
  </script>
</body>
</html>
