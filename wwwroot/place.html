<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MindGobblin Place</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root {
      --bg:#0b0f17; --fg:#eaeaea; --card:#111827; --accent:#3ff0c1; --muted:#9aa4b2;
    }
    * { box-sizing: border-box; }
    html, body { height:100%; }
    body {
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:var(--bg); color:var(--fg);
      display:flex; flex-direction:column;
    }

    header, footer {
      padding: .75rem 1rem; display:flex; align-items:center; justify-content:space-between;
      gap:.75rem;
    }
    header { border-bottom: 1px solid #1b2231; }
    h1 { margin:0; font-size:1rem; letter-spacing:.4px; color:#e9fffb; }

    /* Canvas stage */
    .stage {
      position:relative; flex:1; min-height:0;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    canvas {
      background:#0b0f17;
      image-rendering: pixelated; image-rendering: crisp-edges;
      touch-action: none; /* we manage gestures */
      cursor: crosshair;
      user-select:none;
    }

    /* Floating toolbar */
    .toolbar {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: calc(env(safe-area-inset-bottom) + 12px);
      display:flex; gap:.5rem; padding:.5rem;
      background: rgba(17,24,39,.8); backdrop-filter: blur(8px);
      border: 1px solid #243047; border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      align-items:center;
    }
    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      height:42px; padding:0 .9rem; gap:.5rem;
      border:1px solid #243047; border-radius:12px; background:#152034; color:#dfe7f0;
      font-weight:700; cursor:pointer;
    }
    .btn:hover { border-color:#2d3a54; background:#18253b; }
    .btn:disabled { opacity:.55; cursor:not-allowed; }
    .chip { padding:.2rem .5rem; border-radius:999px; background:#0e1729; border:1px solid #243047; font-variant-numeric:tabular-nums; color:#9fb0c6; }
    .swatch-chip { width:22px; height:22px; border-radius:6px; border:1px solid #0006; }

    /* Color sheet modal */
    .sheet {
      position:fixed; inset:0; display:none; place-items:end center;
      background:rgba(0,0,0,.45);
      padding: env(safe-area-inset-top) 12px calc(env(safe-area-inset-bottom) + 12px);
      z-index:50;
    }
    .sheet.open { display:grid; }
    .sheet-card {
      width:min(560px, 96vw); max-height: 80vh; overflow:auto;
      background:#0f1626; border:1px solid #243047; border-radius:16px;
      padding: 14px; box-shadow: 0 16px 40px rgba(0,0,0,.45);
    }
    .sheet-header { display:flex; align-items:center; justify-content:space-between; gap:.5rem; margin-bottom:.75rem; }
    .sheet-title { margin:0; font-size:1rem; color:#e9fffb; }
    .palette {
      display:grid; grid-template-columns: repeat(auto-fill, minmax(28px,1fr)); gap:8px;
      background:#0b1220; border:1px solid #1e293b; border-radius:12px; padding:10px;
    }
    .swatch {
      width:28px; height:28px; border-radius:8px; border:1px solid #0006; cursor:pointer;
      outline:2px solid transparent; outline-offset:2px;
    }
    .swatch.selected { outline-color: var(--accent); }
    .row { display:flex; align-items:center; justify-content:space-between; gap:.75rem; margin-top:.75rem; flex-wrap:wrap; }
    .muted { color:var(--muted); }
    .color-input {
      background:#0b1220; border:1px solid #1e293b; border-radius:10px; padding:.5rem .75rem; color:#dfe7f0;
      display:flex; align-items:center; gap:.5rem;
    }
    .color-input input[type="color"] {
      appearance:none; inline-size: 36px; block-size: 28px; border:none; padding:0; background:transparent; cursor:pointer; border-radius:8px; overflow:hidden;
    }
    .color-preview {
      width:24px; height:24px; border-radius:6px; border:1px solid #0006;
    }
    footer { border-top: 1px solid #1b2231; color:#97a5bb; font-size:.9rem; }
    .link { color: var(--accent); text-decoration:none; }
    @media (max-width: 720px) {
      h1 { font-size:.95rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>üß†üë∫ MindGobblin Place</h1>
    <div class="chip" id="meta">Loading‚Ä¶</div>
  </header>

  <div class="stage">
    <canvas id="board" width="256" height="256" aria-label="Pixel board"></canvas>
  </div>

  <!-- Floating toolbar -->
  <div class="toolbar">
    <button class="btn" id="colorBtn" title="Pick color">
      <span class="swatch-chip" id="currentSwatch" style="background:#ffffff"></span>
      <span>Color</span>
    </button>
    <button class="btn" id="centerBtn" title="Center board">Center</button>
    <button class="btn" id="placeBtn" disabled>Place Pixel</button>
    <span class="chip" id="cooldown">‚Äî</span>
  </div>

  <!-- Color picker sheet -->
  <div class="sheet" id="colorSheet" aria-hidden="true">
    <div class="sheet-card" role="dialog" aria-modal="true" aria-labelledby="colorTitle">
      <div class="sheet-header">
        <h2 class="sheet-title" id="colorTitle">Choose Color</h2>
        <button class="btn" id="closeSheet">Close</button>
      </div>

      <div class="row">
        <div class="color-input">
          <span class="muted">Custom:</span>
          <input id="wheel" type="color" value="#ffffff" />
          <div id="wheelPreview" class="color-preview" style="background:#ffffff"></div>
          <small class="muted">Snaps to nearest palette color</small>
        </div>
        <div class="row" style="gap:.5rem">
          <span class="muted">Selected:</span>
          <div id="selectedPreview" class="color-preview" style="background:#ffffff"></div>
          <code id="selectedLabel" class="muted">none</code>
        </div>
      </div>

      <p class="muted" style="margin:.75rem 0 .5rem">Palette</p>
      <div class="palette" id="palette"></div>
    </div>
  </div>

  <footer>
    <span>Made with ‚ù§Ô∏è at MindGobblin</span>
    <a class="link" href="/">‚Üê Home</a>
  </footer>

<script>
(async function() {
  // Elements
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d', { alpha:false });
  const metaEl = document.getElementById('meta');
  const placeBtn = document.getElementById('placeBtn');
  const centerBtn = document.getElementById('centerBtn');
  const cooldownEl = document.getElementById('cooldown');
  const colorBtn = document.getElementById('colorBtn');
  const colorSheet = document.getElementById('colorSheet');
  const closeSheet = document.getElementById('closeSheet');
  const paletteEl = document.getElementById('palette');
  const wheel = document.getElementById('wheel');
  const wheelPreview = document.getElementById('wheelPreview');
  const selectedPreview = document.getElementById('selectedPreview');
  const selectedLabel = document.getElementById('selectedLabel');
  const currentSwatch = document.getElementById('currentSwatch');

  // State
  let meta = null;
  let palette = [];
  let board = null;         // Uint8Array of indices
  let offscreen = null;     // offscreen canvas
  let scale = 6;            // CSS-px per board px (initial)
  let offsetX = 0, offsetY = 0; // pan in CSS pixels
  let chosen = null;        // {x,y}
  let selectedIndex = 0;
  let cooldownUntil = 0;
  let lastSince = 0;

  // ---------- Helpers ----------
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const dpr = () => window.devicePixelRatio || 1;

  function fitCanvasToStage() {
    const wrap = canvas.parentElement.getBoundingClientRect();
    const cssW = Math.max(240, Math.floor(wrap.width));
    const cssH = Math.max(240, Math.floor(wrap.height));
    const _dpr = dpr();
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.floor(cssW * _dpr);
    canvas.height = Math.floor(cssH * _dpr);
  }

  function rgb(hex) {
    const h = hex.replace('#','');
    return [parseInt(h.slice(0,2),16), parseInt(h.slice(2,4),16), parseInt(h.slice(4,6),16)];
  }
  function nearestPaletteIndex(hex) {
    const [r,g,b] = rgb(hex);
    let best = 0, bestD = 1e9;
    for (let i=0;i<palette.length;i++){
      const [R,G,B] = rgb(palette[i]);
      const d = (r-R)*(r-R) + (g-G)*(g-G) + (b-B)*(b-B);
      if (d < bestD) { bestD = d; best = i; }
    }
    return best;
  }

  function rebuildOffscreen() {
    if (!meta || !board) return;
    offscreen = document.createElement('canvas');
    offscreen.width = meta.width;
    offscreen.height = meta.height;
    const octx = offscreen.getContext('2d', { alpha:false });
    const img = octx.createImageData(meta.width, meta.height);
    for (let i = 0; i < board.length; i++) {
      const hex = palette[board[i]] || "#000000";
      const r = parseInt(hex.slice(1,3),16);
      const g = parseInt(hex.slice(3,5),16);
      const b = parseInt(hex.slice(5,7),16);
      const j = i*4;
      img.data[j] = r; img.data[j+1] = g; img.data[j+2] = b; img.data[j+3] = 255;
    }
    octx.putImageData(img, 0, 0);
  }

  function draw() {
    if (!meta || !offscreen) return;
    fitCanvasToStage();

    const _dpr = dpr();
    ctx.setTransform(_dpr,0,0,_dpr,0,0);
    ctx.imageSmoothingEnabled = false;

    // Clear
    ctx.fillStyle = '#0b0f17';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Pan/Zoom in CSS px
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    // Draw board
    ctx.drawImage(offscreen, 0, 0);

    // Selection
    if (chosen) {
      ctx.strokeStyle = '#ffffffcc';
      ctx.lineWidth = 1 / scale;
      ctx.strokeRect(chosen.x, chosen.y, 1, 1);
    }
  }

  function centerBoard() {
    if (!meta) return;
    const rect = canvas.getBoundingClientRect();
    offsetX = Math.floor((rect.width  - meta.width  * scale)/2);
    offsetY = Math.floor((rect.height - meta.height * scale)/2);
    draw();
  }

  function screenToBoard(cx, cy) {
    const rect = canvas.getBoundingClientRect(); // CSS px
    const x = (cx - rect.left - offsetX) / scale;
    const y = (cy - rect.top  - offsetY) / scale;
    return { x: Math.floor(x), y: Math.floor(y) };
  }

  function setSelected(i) {
    selectedIndex = i;
    const hex = palette[i];
    selectedPreview.style.background = hex;
    selectedLabel.textContent = `#${i} ${hex}`;
    currentSwatch.style.background = hex;

    // mark in palette
    for (const el of paletteEl.querySelectorAll('.swatch')) {
      el.classList.toggle('selected', parseInt(el.dataset.idx,10) === i);
    }
    updatePlaceButton();
  }

  function updatePlaceButton() {
    const cd = Math.max(0, Math.ceil((cooldownUntil - Date.now())/1000));
    cooldownEl.textContent = cd > 0 ? `${cd}s` : 'ready';
    placeBtn.disabled = (chosen == null) || cd > 0;
  }

  // ---------- Data ----------
  async function fetchMeta() {
    const r = await fetch('/api/place/meta');
    meta = await r.json();
    palette = meta.palette;
    metaEl.textContent = `Board ${meta.width}√ó${meta.height} ‚Ä¢ Cooldown ${meta.cooldownSeconds}s`;
    // Build palette UI
    paletteEl.innerHTML = '';
    palette.forEach((hex, idx) => {
      const div = document.createElement('div');
      div.className = 'swatch';
      div.style.background = hex;
      div.title = `${idx} ${hex}`;
      div.dataset.idx = idx;
      div.onclick = () => setSelected(idx);
      paletteEl.appendChild(div);
    });
  }

  async function fetchBoard() {
    const r = await fetch('/api/place/board');
    const b64 = await r.text();
    board = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    rebuildOffscreen();
    // pick a comfy starting zoom based on viewport
    const stage = canvas.parentElement.getBoundingClientRect();
    scale = Math.floor(Math.min(stage.width / meta.width, stage.height / meta.height));
    scale = clamp(scale, 3, 12);
    centerBoard();
    draw();
  }

  async function fetchUpdates() {
    const r = await fetch('/api/place/updates?since=' + lastSince);
    const data = await r.json().catch(()=>({}));
    if (data.since != null) lastSince = data.since;
    if (data.updates && data.updates.length && board) {
      for (const u of data.updates) {
        const i = u.y * meta.width + u.x;
        if (i >= 0 && i < board.length) board[i] = u.colorIndex;
      }
      rebuildOffscreen();
      draw();
    }
  }

  async function placePixel() {
    if (placeBtn.disabled || !chosen) return;
    const body = JSON.stringify({ x: chosen.x, y: chosen.y, colorIndex: selectedIndex });
    const r = await fetch('/api/place/set', { method:'POST', headers:{'Content-Type':'application/json'}, body });
    const js = await r.json().catch(()=>({}));
    if (!r.ok) {
      alert(js.error || 'Failed to place');
      return;
    }
    // optimistic update
    const i = chosen.y * meta.width + chosen.x;
    board[i] = selectedIndex;
    rebuildOffscreen();
    draw();
    cooldownUntil = Date.now() + (meta.cooldownSeconds*1000);
    updatePlaceButton();
  }

  // ---------- Gestures ----------
  // Pan (pointer)
  let dragging = false, lastX = 0, lastY = 0;
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    dragging = true; lastX = e.clientX; lastY = e.clientY;
  });
  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    offsetX += (e.clientX - lastX);
    offsetY += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    draw();
  });
  function endDrag(){ dragging = false; }
  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);
  canvas.addEventListener('pointerleave', endDrag);

  // Choose target (single tap/click)
  let tapTimer = 0;
  function canPlace() {
  const now = Date.now();
  const cdRemain = Math.max(0, Math.ceil((cooldownUntil - now)/1000));
  return selectedColor != null && chosen != null && cdRemain <= 0;
}

// Single click = pick target only
canvas.addEventListener('click', (e) => {
  const p = screenToBoard(e.clientX, e.clientY);
  if (!meta) return;
  if (p.x < 0 || p.y < 0 || p.x >= meta.width || p.y >= meta.height) return;
  chosen = p;
  // (If you show a hint somewhere, update it here)
  updatePlaceButton();
  draw();
});

// Desktop: double-click = place now
canvas.addEventListener('dblclick', async (e) => {
  e.preventDefault();
  const p = screenToBoard(e.clientX, e.clientY);
  if (!meta) return;
  if (p.x < 0 || p.y < 0 || p.x >= meta.width || p.y >= meta.height) return;
  chosen = p;
  draw();

  if (canPlace()) {
    await placePixel();
  } else {
    // Optional UX: if no color picked, open your color picker here
    // openColorPicker();
  }
});

// Mobile: detect double-tap to place now
let lastTapTime = 0;
let lastTapXY = null;
canvas.addEventListener('touchend', async (e) => {
  if (e.touches.length > 0) return; // ignore if still touching
  const t = Date.now();

  // Use changedTouches[0] for the end position
  const touch = e.changedTouches && e.changedTouches[0];
  if (!touch) return;

  const p = screenToBoard(touch.clientX, touch.clientY);
  if (!meta) return;
  if (p.x < 0 || p.y < 0 || p.x >= meta.width || p.y >= meta.height) return;

  // Double-tap: within 300ms and ~20px of last tap
  const isNear = lastTapXY
    ? Math.hypot(p.x - lastTapXY.x, p.y - lastTapXY.y) < 20
    : false;

  if (t - lastTapTime < 300 && isNear) {
    e.preventDefault();
    chosen = p;
    draw();
    if (canPlace()) {
      await placePixel();
    } else {
      // Optional: open color picker if none selected
      // openColorPicker();
    }
    lastTapTime = 0; // reset
    lastTapXY = null;
  } else {
    // First tap just selects
    chosen = p;
    draw();
    updatePlaceButton();
    lastTapTime = t;
    lastTapXY = p;
  }
}, { passive: true });
  // Pinch zoom
  function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
let pinch = null; // {d0}

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 2) {
    e.preventDefault();
    const [a,b] = e.touches;
    pinch = { d0: dist(a,b) };
  }
}, {passive:false});

canvas.addEventListener('touchmove', (e) => {
  if (e.touches.length === 2 && pinch) {
    e.preventDefault();
    const [a,b] = e.touches;
    const d1 = dist(a,b);
    const cx = (a.clientX + b.clientX) / 2; // <-- recompute center each frame
    const cy = (a.clientY + b.clientY) / 2;

    // dampen zoom ~19x so it feels steady
    const raw = d1 / pinch.d0;
    const factor = Math.pow(raw, 1/19);

    zoomAt(cx, cy, factor);
    pinch.d0 = d1; // update baseline for next frame
  }
}, {passive:false});
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const raw = e.deltaY < 0 ? 1.1 : 0.9;
  const factor = 1 + (raw - 1)/19; // dampened
  zoomAt(e.clientX, e.clientY, factor);
}, {passive:false});


  // Wheel zoom (desktop / trackpad)
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const raw = e.deltaY < 0 ? 1.1 : 0.9;
    const factor = 1 + (raw - 1)/19; // also dampen 19x
    zoomAt(e.clientX, e.clientY, factor);
  }, {passive:false});

function zoomAt(cx, cy, factor){
  // screen (CSS px) -> world (board px) before zoom
  const rect = canvas.getBoundingClientRect();
  const sx = cx - rect.left;
  const sy = cy - rect.top;
  const wx = (sx - offsetX) / scale;
  const wy = (sy - offsetY) / scale;

  // new scale (clamped)
  const newScale = Math.max(1, Math.min(32, scale * factor));

  // choose new offset so (wx,wy) stays exactly under (cx,cy)
  offsetX = sx - wx * newScale;
  offsetY = sy - wy * newScale;

  scale = newScale;
  draw();
}


  // ---------- Color sheet ----------
  function openSheet(){ colorSheet.classList.add('open'); colorSheet.setAttribute('aria-hidden', 'false'); }
  function closeSheetFn(){ colorSheet.classList.remove('open'); colorSheet.setAttribute('aria-hidden', 'true'); }

  colorBtn.addEventListener('click', openSheet);
  closeSheet.addEventListener('click', closeSheetFn);
  colorSheet.addEventListener('click', (e) => {
    if (e.target === colorSheet) closeSheetFn();
  });

  wheel.addEventListener('input', () => {
    const hex = wheel.value;
    wheelPreview.style.background = hex;
    const snap = nearestPaletteIndex(hex);
    setSelected(snap);
  });

  // ---------- Buttons ----------
  centerBtn.addEventListener('click', () => { centerBoard(); draw(); });
  placeBtn.addEventListener('click', placePixel);

  // Cooldown ticker
  setInterval(updatePlaceButton, 250);
  // Updates ticker
  setInterval(fetchUpdates, 3000);
  window.addEventListener('resize', () => { centerBoard(); draw(); });

  // ---------- Boot ----------
  await fetchMeta();
  await fetchBoard();
  await fetchUpdates();
  setSelected(0);
  currentSwatch.style.background = palette[0] || '#ffffff';
})();
</script>
</body>
</html>
